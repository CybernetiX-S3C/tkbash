#!/bin/bash

# 20170812 tkbash @ https://github.com/phil294/tkbash.git
# eochgls@web.de
#  .___.
#  {o,o}
# /)___)
# --"-"--

set -e # exit on error

die() {
	echo "call 'tkbash --help' for help."
	exit "$@"
}

BASH_MINIMUM_VERSION="4.2"
# todo does not support busybox
#[[ $(sort -V <<< $BASH_VERSION$'\n'$BASH_MINIMUM_VERSION |head -1) != $BASH_MINIMUM_VERSION ]] && echo "Minimum bash version required: $BASH_MINIMUM_VERSION" && die 24
#command -v wish >/dev/null || (echo "You need to have wish (tcl/tk) installed." && die 25)

TMP="/tmp/__tkbash1.0_"
mkdir -p "$TMP"

show_help() {
	COLOR_BOLD="$(tput bold)"
	COLOR_RESET="$(tput sgr0)"
	echo ">>> ${COLOR_BOLD}TkBash${COLOR_RESET}. Basic Bash superset for Tcl/Tk gui. Just a layer, NO reimplementation of Tk. Place elements using absolute coordinates x/y/w/h."
	echo
	echo "${COLOR_BOLD}USAGE${COLOR_RESET}:"
	echo -e "\t${COLOR_BOLD}tkbash <gui_id> [<element>] <variable> [-options...]${COLOR_RESET}"
	echo -e "\t\tAdd / edit element."
	echo -e "\t${COLOR_BOLD}tkbash <gui_id> get <variable>${COLOR_RESET}"
	echo -e "\t\tPrint the value of the associated element."
	echo -e "\t${COLOR_BOLD}tkbash <gui_id> window [-options...]${COLOR_RESET}"
	echo -e "\t\tSet window properties."
	echo
	echo -e "\t${COLOR_BOLD}tkbash <gui_id> [<variable>] --tkcommand <command>${COLOR_RESET}"
	echo -e "\t\tExecute custom Tcl/Tk code. For advanced element configuration not provied by tkbash itself. \"--tkcommand\" can also be \"--tk\". Variable can be ommitted for full access. Example: \"tkbash mygui mybutton --tkcommand 'configure -font verdana'\" or \"tkbash mygui --tkcommand 'wm maxsize .w 200 200'\". Note: toplevel root window in tkbash is \".w\"."
	echo -e "\t${COLOR_BOLD}[any command...] --debug, --print, --log${COLOR_RESET}"
	echo -e "\t\tPrint all commands sent to the wish background process (Tcl/Tk code) to stderr. For debugging."
	echo
	echo
	echo -e "\t\t${COLOR_BOLD}gui_id${COLOR_RESET}"
	echo -e "\t\t\tUnique identifier for the GUI. To be reused with subsequent tkbash calls."
	echo -e "\t\t${COLOR_BOLD}element${COLOR_RESET}"
	echo -e "\t\t\tAny of the elements listed below. Required when adding a new one."
	echo -e "\t\t${COLOR_BOLD}variable${COLOR_RESET}"
	echo -e "\t\t\tVariable to hold the value associated with the element."
	echo
	echo -e "\t\tWhen adding an element for the first time, all positional options are required (-x, -y, -w, -h). See general element options."
	echo -e "${COLOR_BOLD}Window${COLOR_RESET}"
	echo -e "Set options for the entire interface / window as described above. You can set width and height if BOTH are specified (if w and y are also specified, you will set also the window position)."
	echo -e "\t${COLOR_BOLD}--theme${COLOR_RESET} <themename>"
	echo -e "\t\tSet the look and feel used by all ttk-controls. Available themes usually include clam, alt, default and classic."
	echo -e "\t${COLOR_BOLD}--title${COLOR_RESET} <title>"
	echo -e "\t\tSet the window title."
	echo -e "\t${COLOR_BOLD}--alwaysontop, --topmost${COLOR_RESET} <switch>"
	echo -e "\t\tSet the window's always on top behaviour. Activate with 0, deactivate with 1."
	echo -e "\t${COLOR_BOLD}--maximize${COLOR_RESET}"
	echo -e "\t\tMaxmize the window to fullscreen."
	echo -e "\t${COLOR_BOLD}--alpha, --transparency${COLOR_RESET} <alpha>"
	echo -e "\t\tSet the transparency of the entire window. Floating value between 0 and 1."
	echo -e "\t${COLOR_BOLD}--icon${COLOR_RESET} <iconpath>"
	echo -e "\t\tSet the window icon."
	echo -e "\t${COLOR_BOLD}--background, --backgroundcolor, --bck, --bg${COLOR_RESET} <color>"
	echo -e "\t\tSet the background color for the entire window. You might need to also set the background for individual elements for they do not inherit this setting. Use common color names like red, yellow etc. or hex notation #ff1234."
	
	echo -e "\t${COLOR_BOLD}--resizable${COLOR_RESET} <switch>"
	echo -e "\t\tSet the window's resizable behaviour. Activate with 0, deactivate with 1."
	echo -e "\t${COLOR_BOLD}--iconify${COLOR_RESET}"
	echo -e "\t\tMinimize the window."
	echo -e "\t${COLOR_BOLD}--hide${COLOR_RESET}"
	echo -e "\t\tHide the window by detaching it from the Window Manager."
	echo -e "\t${COLOR_BOLD}--show${COLOR_RESET}"
	echo -e "\t\tSet the window visible by re-attaching it to the Winodow Manager."
	echo -e "\t${COLOR_BOLD}--close, --exit, --quit, --destroy${COLOR_RESET}"
	echo -e "\t\tClose the window programmatically. This is equal to the user pressing the X button or pressing alt+f4."
	echo -e "\t${COLOR_BOLD}--hotkey, --bind, --shortcut${COLOR_RESET}"
	echo -e "\t\tAdd an action to be executed when a key (\"sequence\") is pressed. Possible sequences: See https://www.tcl.tk/man/tcl8.4/TkCmd/bind.htm#M5. Specify the commands to be executed use the --command option. Example: \"tkbash mygui window --hotkey Escape --command 'echo You pressed Escape.'\" Also see --command note below."
	echo -e "\t${COLOR_BOLD}--onclose${COLOR_RESET}"
	echo -e "\t\tAdd an action to be executed when the window is closed. Specify the commands to be executed using the --command option. Example: \"tkbash mygui window --onclose --command 'echo tkbash now exits.'\" The GUI will only exit once the --command has finished. Also see --command note below."
	echo -e "\t${COLOR_BOLD}--exist${COLOR_RESET}"
	echo -e "\t\tPrints 1 if the specified <gui_id> belongs to a running window, 0 otherwise."
	echo -e "\t${COLOR_BOLD}--notitlebar, --nobar, --nocaption, --nodecorations, --tooltip, --popup, --overrideredirect${COLOR_RESET}"
	echo -e "\t\tImportant: This option is only considered at window creation. Thus, it should be part of the very first tkbash call made for this <gui_id>. - Make the GUI unmapped: The window cannot be moved, typed into, have hotkeys assigned etc. The window is automatically always-on-top and does not appear in the panel. This option might be interesting for creating a tooltip. Appropriate buttons should be configured so the user can actually close the window (see window --close)."
	echo -e "\t${COLOR_BOLD}--onclick${COLOR_RESET}"
	echo -e "\t\tAdd an action to be executed when the user clicks anywhere on the gui. Specify the commands to be executed using the --command option. Example: \"tkbash mygui window --onclick --command 'echo You clicked the window.'\" Also see --command note below."
	echo
	echo -e "${COLOR_BOLD}ELEMENTS${COLOR_RESET}"
	echo -e "\t${COLOR_BOLD}button${COLOR_RESET} / submit"
	echo -e "\t\tOptions:"
	echo -e "\t\t\t${COLOR_BOLD}-t, --text, --content${COLOR_RESET} <text>"
	echo -e "\t\t\t\tThe text that will be displayed on the button."
	echo -e "\t\t\t${COLOR_BOLD}-c, --command${COLOR_RESET} <command>"
	echo -e "\t\t\t\tCode to be executed when the element is clicked. Also see --command note below."
	echo -e "\t\tGet:"
	echo -e "\t\t\tYou cannot retrieve any value from a button."
	echo -e "\t${COLOR_BOLD}text${COLOR_RESET} / input / edit / textfield / textarea"
	echo -e "\t\tA text element is a multiline input area for text."
	echo -e "\t\tOptions:"
	echo -e "\t\t\t${COLOR_BOLD}--scrollbar${COLOR_RESET} <switch>"
	echo -e "\t\t\t\tShow or hide the vertical scrollbar next to the textfield. <switch> is 0 or 1."
	echo -e "\t\t\t${COLOR_BOLD}-t, --text, --content${COLOR_RESET} <text>"
	echo -e "\t\t\t\tSet the contents of the text field."
	echo -e "\t\t\t${COLOR_BOLD}--ignore-return, --ignore-newline, --entry, --one-row${COLOR_RESET}"
	echo -e "\t\t\t\tThe user cannot type newlines. If combined with an appropriate height, this could also be used as a form input."
	echo -e "\t\tGet:"
	echo -e "\t\t\tPrints the contents of the text field."
	echo -e "\t${COLOR_BOLD}label${COLOR_RESET} / p"
	echo -e "\t\tA label element displays plain text somewhere on the gui."
	echo -e "\t\tOptions:"
	echo -e "\t\t\t${COLOR_BOLD}-t, --text, --content${COLOR_RESET} <text>"
	echo -e "\t\t\t\tSet the contents of the label."
	echo -e "\t\tGet:"
	echo -e "\t\t\tYou cannot retrieve any value from a label."
	echo -e "\t${COLOR_BOLD}image${COLOR_RESET} / picture / img / bmp / bitmap"
	echo -e "\t\tDisplay an image."
	echo -e "\t\tOptions:"
	echo -e "\t\t\t${COLOR_BOLD}--image${COLOR_RESET} <path>"
	echo -e "\t\t\t\tPath of the image to be shown. Not all formats are supported. (yes: png, no: jpg)"
	echo -e "\t\tGet:"
	echo -e "\t\t\tYou cannot retrieve any value from an image."
	echo -e "\t\tNote: Internally, this does the same like 'label', meaning these two element names are interchangeable."
	echo -e "\t${COLOR_BOLD}checkbutton${COLOR_RESET} / checkbox / check / tick / toggle"
	echo -e "\t\tFor boolean values. If neither --checked nor --unchecked is passed, the checkbutton is in a neither-state (pristine)"
	echo -e "\t\tOptions:"
	echo -e "\t\t\t${COLOR_BOLD}-t, --text, --content${COLOR_RESET} <text>"
	echo -e "\t\t\t\tSet the text to be displayed next to the tick."
	echo -e "\t\t\t${COLOR_BOLD}-c, --command${COLOR_RESET} <command>"
	echo -e "\t\t\t\tCode to be executed when the element is clicked. Also see --command note below."
	echo -e "\t\t\t${COLOR_BOLD}--selected, --checked${COLOR_RESET}"
	echo -e "\t\t\t\tSet selected state to 1."
	echo -e "\t\t\t${COLOR_BOLD}--deselected, --unchecked${COLOR_RESET}"
	echo -e "\t\t\t\tSet selected state to 0."
	echo -e "\t\tGet:"
	echo -e "\t\t\tPrints 1 when checked, 0 when unchecked, nothing when pristine."
	echo -e "\t${COLOR_BOLD}radiobutton${COLOR_RESET} / radio"
	echo -e "\t\tMultiple radiobuttons form a group. Only one radiobutton in a group can be active at the same time."
	echo -e "\t\tOptions:"
	echo -e "\t\t\t[required] ${COLOR_BOLD}--group${COLOR_RESET} <group-id>"
	echo -e "\t\t\t\tAssign this radiobutton to a group. Can be any string. See 'get' below. In contrary to most options, this one can not be changed afterwards, meaning if you pass it any other time that on element creation, it is ignored."
	echo -e "\t\t\t${COLOR_BOLD}-t, --text, --content${COLOR_RESET} <text>"
	echo -e "\t\t\t\tSet the text to be displayed next to the radiobutton."
	echo -e "\t\t\t${COLOR_BOLD}-c, --command${COLOR_RESET} <command>"
	echo -e "\t\t\t\tCode to be executed when the element is clicked. Also see --command note below."
	echo -e "\t\t\t${COLOR_BOLD}--selected, --checked${COLOR_RESET}"
	echo -e "\t\t\t\tSet this radio as the selected one from its group."
	echo -e "\t\tGet:"
	echo -e "\t\t\tEvery radiobutton gets internally assigned a number. The first radiobutton of a group has the number 0, the second 1, third 2 and so on. When you call the 'get' method for any of the radios contained in this group, it will print out the number of the selected radio (or nothing when pristine) in its group: 0 or 1 or 2 or whatever. The name of the group does not matter for retrieving the value. The group is only needed when a radiobutton is created."
	echo -e "\t${COLOR_BOLD}combobox${COLOR_RESET} / select / dropdown / dropdownmenu"
	echo -e "\t\tSelect one of many values. Behaves like a classical HTML-select (the Tk-state 'readonly' is active)."
	echo -e "\t\tOptions:"
	echo -e "\t\t\t${COLOR_BOLD}-t, --text, --content${COLOR_RESET} <text>"
	echo -e "\t\t\t\tA pipe-delimited list (e.g. \"option1|option2|option3\") of options for this select which the user will be able to choose from. Set the default value by appending two pipes. For example \"option1|option2||option3\" to have option2 be selected by default. Otherwise, the first one will be selected."
	echo -e "\t\t\t${COLOR_BOLD}-c, --command${COLOR_RESET} <command>"
	echo -e "\t\t\t\tCode to be executed when an item is chosen. Also see --command note below."
	echo -e "\t\tGet:"
	echo -e "\t\t\tPrints the selected value, e.g. \"option1\" when the first value is chosen."
	echo
	echo -e "${COLOR_BOLD}General element options${COLOR_RESET}"
	echo -e "\t${COLOR_BOLD}-x <x-position>${COLOR_RESET}"
	echo -e "\t(optional) ${COLOR_BOLD}-X, --relx <x-position>${COLOR_RESET}"
	echo -e "\t${COLOR_BOLD}-y <y-position>${COLOR_RESET}"
	echo -e "\t(optional) ${COLOR_BOLD}-Y, --rely <y-position>${COLOR_RESET}"
	echo -e "\t${COLOR_BOLD}-w, --width <width>${COLOR_RESET}"
	echo -e "\t${COLOR_BOLD}-h, --height <height>${COLOR_RESET}"
	echo -e "\t${COLOR_BOLD}--disabled${COLOR_RESET} <switch>"
	echo -e "\t\tDissables (greys out) the command. Can be used with any element, will however take no action  on labels. <switch> is 0 or 1."
	echo -e "\t${COLOR_BOLD}--notheme, --nostyle${COLOR_RESET}"
	echo -e "\t\tMake the element ignore the current theme. Can only be used upon element creation (ignored in subsequent calls!). Typically only needed when you want to style the element customly. --It is not possible to apply individual colors to themed elements. This does not apply to the text element, but you can pass this option there either way. Sorry about this mess :( Tk themes just work like that. - Example: \"tkbash mygui button [position args..] -t Click --notheme --background '#789987'\""
	echo -e "\t${COLOR_BOLD}--foreground, --foregroundcolor, --color, --textcolor, --fg${COLOR_RESET} <color>"
	echo -e "\t\tSet the foreground color (typically, text color). Use common color names like red, yellow etc. or hex notation #ff1234. Important: element needs to have been created with --notheme."
	echo -e "\t${COLOR_BOLD}--background, --backgroundcolor, --bck, --bg${COLOR_RESET} <color>"
	echo -e "\t\tSet the background color. Use common color names like red, yellow etc. or hex notation #ff1234. Important: element needs to have been created with --notheme."
	echo
	echo -e "${COLOR_BOLD}Additional notes${COLOR_RESET}"
	echo -e "Note on the ${COLOR_BOLD}-c, --command${COLOR_RESET} option: The command contents will be written into a temp file and then called on action. You can preceed this with your custom shebang. Thus, session variables cannot be accessed."
}

########################### OPTION PARSING & VARIABLES INITIALIZATION

OPTIONS=w:h:x:X:y:Y:c:t:
LONGOPTIONS=help,width:,height:,relx:,rely:,command:,alwaysontop:,maximize,resizable:,text:,content:,tk:,tkcommand:,disabled:,disable:,image:,group:,theme:,title:,iconify,hide,show,close,icon:,alpha:,transparency:,exit,destroy,topmost:,hotkey:,shortcut:,bind:,quit,ignore-return,entry,one-row,ignore-newline,selected,select,check,checked,deselected,unselected,deselect,unselect,unchecked,uncheck,onclose,onclosed,exist,exists,notitlebar,nobar,nocaption,nodecorations,nodecoration,overrideredirect,tooltip,popup,onclick,scrollbar:,foreground:,foregroundcolor:,color:,colour:,foregroundcolour:,textcolor:,textcolour:,background:,backgroundcolor:,backgroundcolour:,bck:,bg:,fg:,debug,print,log,notheme,nostyle
PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTIONS --name "$0" -- "$@") || die 27
if [[ $? -ne 0 ]]; then
	die 2
fi
eval set -- "$PARSED"
while true; do
	case "$1" in
		--help)
			show_help
			exit 0 ;;
		-w|--width) WIDTH="$2" && shift 2 ;;
		-h|--height) HEIGHT="$2" && shift 2 ;;
		-x) X="$2" && shift 2 ;;
		-y) Y="$2" && shift 2 ;;
		-X|--relx) RELX="$2" && shift 2 ;;
		-Y|--rely) RELY="$2" && shift 2 ;;
		-v|--var|--variable) VAR_NAME="$2" && shift 2 ;;
		-c|--command) COMMAND="$2" && shift 2 ;;
		--alwaysontop|--topmost) ALWAYS_ON_TOP="$2" && shift 2 ;;
		--maximize) MAXIMIZE="1" && shift ;;
		--resizable) RESIZABLE="$2" && shift 2 ;;
		--theme) THEME="$2" && shift 2 ;;
		--iconify) ICONIFY="1" && shift ;;
		--hide) HIDE="1" && shift ;;
		--show) SHOW="1" && shift ;;
		--close|--exit|--destroy|--quit) CLOSE="1" && shift ;;
		--title) TITLE="$2" && shift 2 ;;
		--icon) ICON="$2" && shift 2 ;;
		--alpha|--transparency) ALPHA="$2" && shift 2 ;;
		--hotkey|--shortcut|--bind) HOTKEY="$2" && shift 2 ;;
		-t|--text|--content) CONTENT="$2" && shift 2 ;;
		--tk|--tkcommand) TKCOMMAND="$2" && shift 2 ;;
		--disabled|--disable) DISABLED="$2" && shift 2 ;;
		--image) IMAGE="$2" && shift 2 ;;
		--group) GROUP="$2" && shift 2 ;;
		--ignore-return|--ignore-newline|--entry|--one-row) IGNORE_RETURN="1" && shift ;;
		--selected|--select|--check|--checked) SELECTED=1 && shift ;;
		--unselected|--deselected|--unselect|--deselect|--uncheck|--unchecked) SELECTED=0 && shift ;;
		--onclose|--onclosed) ON_CLOSE=1 && shift ;;
		--exist|--exists) EXIST=1 && shift ;;
		--notitlebar|--nobar|--nocaption|--nodecorations|--nodecoration|--overrideredirect|--tooltip|--popup) NOTITLEBAR=1 && shift ;;
		--onclick) ON_CLICK=1 && shift;;
		--scrollbar) SCROLLBAR="$2" && shift 2 ;;
		--foreground|--foregroundcolor|--color|--colour|--foregroundcolour|--textcolor|--textcolour|--fg) FOREGROUND="$2" && shift 2 ;;
		--background|--backgroundcolor|--backgroundcolour|--bck|--bg) BACKGROUND="$2" && shift 2 ;;
		--debug|--print|--log) DEBUG="1" && shift ;;
		--notheme|--nostyle) NOTHEME="1" && shift ;;
		--)
			shift
			break ;;
		*)
			echo "error parsing options ):"
			exit 3 ;;
	esac
done

GUI_ID="$1"
WISH_PIPE="${TMP}/${GUI_ID}_wishpipe"
#WISH_OUTFILE="${TMP}/${GUI_ID}_outfile"
COMMUNICATION_FILE="${TMP}/${GUI_ID}_communicationfile"
GET_REQUEST=0
[ -z "$GUI_ID" ] && echo "specify gui id!" && die 1
require_variable() {
	[ -z "$VAR_NAME" ] && echo "specify variable name!" && die 14
	[[ "$VAR_NAME" == *" "* ]] && echo "variable cannot contain spaces!" && die 21
	return 0
}
if [ "$2" = "get" ] && [ $# = 3 ]; then
	ACTION=
	VAR_NAME="$3"
	GET_REQUEST=1
	require_variable
elif [ "$2" = "window" ] && [ $# = 2 ]; then
	ACTION="window"
	VAR_NAME=
elif [ $# = 2 ]; then
	VAR_NAME="$2"
	require_variable
elif [ $# = 3 ]; then
	ACTION="$2"
	VAR_NAME="$3"
	require_variable
elif [ $# = 1 ]; then
	[ ! -v TKCOMMAND ] && require_variable # = exit
	# else: tkcommand.
else
	echo "Too many arguments!" && die 22
fi
[[ "$HOTKEY" == *" "* ]] && echo "hotkey name cannot contain spaces!" && die 21
[[ "$GUI_ID" == *" "* ]] && echo "gui name cannot contain spaces!" && die 21
[[ "$GROUP" == *" "* ]] && echo "group name cannot contain spaces!" && die 21

################################# helper functions

tcl_esc() {
	#todo wtf
	# http://tcl.tk/man/tcl8.5/TclCmd/Tcl.htm
	echo "$1" |sed 's/\\/\\\\/g' |sed 's/"/\\"/g' |sed 's/\$/\\\$/g' |sed 's/\[/\\\[/g' |sed 's/\]/\\\]/g' |sed 's/{/\\{/g' |sed 's/}/\\}/g'
}
tcl_str() {
	local a="$(tcl_esc "$1")"
	echo "\"$a\""
}
# write commands $2 into tmp command file for identifier $1, so the file can later be run by tcl proc onaction
write_command_file() {
	echo "${2}" > "${TMP}/${GUI_ID}_${1}_command" && chmod +x "${TMP}/${GUI_ID}_${1}_command"
}

wish_exec() {
	# communicate unidirectionally with running wish process
	echo "$1" >"$WISH_PIPE"
	[ -v DEBUG ] && echo "$1" >&2
	return 0
}

wish_get() {
	# communicate bidirectionally with running wish process
	rm -f "$COMMUNICATION_FILE"
	wish_exec "
		if {[catch {set result [$1] }]} {
			puts stderr \"error while communicating with wish:\"
			puts stderr \"$::errorCode\"
		}
		if {[info exists result]} {
			exec echo \$result > $(tcl_str "$COMMUNICATION_FILE")
		} else {
			exec echo \"________EMPTY________\" > $(tcl_str "$COMMUNICATION_FILE")
		}" # todo: ^ really bad error handling. use another pipe?
		# todo ^ put into tcl function???

	# wait for response: cannot use timeout due to weird busybox behaviour
	(
		(
			while ! [ -s "$COMMUNICATION_FILE" ]; do
				sleep 0.001
			done
		) &
		local wait_for_response_pid=$!
		trap -- "" SIGTERM
		(
			sleep 1 # wait 1 sec for response at maximum
			kill $wait_for_response_pid || true
		) >/dev/null 2>&1 &
		local terminator_pid=$!
		wait $wait_for_response_pid || return 22
		kill $terminator_pid # doesnt work for some reason, but does not really matter (stops after 1 sec anyway)
	) || return 22

	# parse response
	local wish_response="$(cat "$COMMUNICATION_FILE")"
	rm "$COMMUNICATION_FILE"
	[[ "$wish_response" == "________EMPTY________" ]] && return 22002
	echo "$wish_response"
	return 0
}

################################# do things

WVAR_ESC="$(tcl_esc .w.$VAR_NAME)"

if [ -n "$EXIST" ]; then
	[[ -p "$WISH_PIPE" ]] && echo 1 || echo 0
	exit 0
fi

if ! [[ -p "$WISH_PIPE" ]]; then
	# gui does not exist yet. initialize stuff
	# set up new pipe
	mkfifo "$WISH_PIPE"
	WISH_PIPE_HELPER=${WISH_PIPE}_
	mkfifo "$WISH_PIPE_HELPER"
	set -m # enable job control (so wishpipe job has its own group)
	(
		# read from wishpipe contineously and pipe to wish.
		# cannot use '|wish' because wish needs to exit by itself (see below) and this job should end afterwards too. --> use wish<pipe syntax
		# cat instead of tail because busybox: https://unix.stackexchange.com/a/392754/103120
		# i have no idea why the very next line is needed but it is. pipe / pipe_helper can also be exchanged in any funny way. could not get it to run without the helper pipe.
		cat 0<> "$WISH_PIPE_HELPER" > "$WISH_PIPE" &
		tail_pid=$!
		wish < "$WISH_PIPE"
		# wish exited. clean up: remove command files, wishpipe etc.
		kill -INT $tail_pid
		rm "${TMP}/${GUI_ID}"*
		exit 0
	) &
	set +m
	commandfile_tcl="\"$(tcl_esc "${TMP}/${GUI_ID}")_\${trigger}_command\""
	if [ "$NOTITLEBAR" = 1 ]; then # thanks to Donal Fellows! https://stackoverflow.com/a/30885979/3779853
		additional_content_notitlebar="wm overrideredirect .w 1
			wm attribute .w -type toolltip" # it is up to the window manager how to interpret the window type
	fi
	wish_exec "
		# hide default window
		wm withdraw .
		# custom toplevel: .w
		toplevel .w
		$additional_content_notitlebar
		# create listenerhandler: execute respective script on command / bind etc. used by -command options below. can be nothing.
		proc onaction {trigger} {
			if { [file exists ${commandfile_tcl}] == 1} {
				return [ exec ${commandfile_tcl} >@stdout 2>@stderr & ]
			}
			return -1
		}
		# default: window title = script name
		wm title .w $(tcl_str "$(basename "$0")")
		# on exit: clean up
		proc onexit {} {
			set pid [ onaction onclose ]
			while {[file exists /proc/\$pid]} {
				# onclose action needs to terminate before remaining scripts and pipe can be deleted
				exec /bin/sleep 0.02
			}
			# exec kill -INT -$wish_group_id # need to send 'exit' to tcl instead because tcl canNOT handle signals natively. needed sometimes (to have xclip changes to clipboard be persistent, for example). alternative would be Tcl_finalize from <tcl.h> via custom extension, but tkbash requires no external lib
			exit
		}
		# on window close: call custom exit
		wm protocol .w WM_DELETE_WINDOW {
			onexit
		}
		# on user click: custom handler
		bind .w <1> \"onaction onclick\"
		"
fi

handle_window_commands() {
	[ -v TITLE ] && wish_exec "wm title .w $(tcl_str "${TITLE}")"
  if ([ -n "$WIDTH" ] && [ -n "$HEIGHT" ]); then
    if ([ -n "$X" ] && [ -n "$Y" ]); then
      wish_exec "wm geometry .w $(tcl_str "${WIDTH}x${HEIGHT}+${X}+${Y}")"
    else
      wish_exec "wm geometry .w $(tcl_str "${WIDTH}x${HEIGHT}")"
    fi
  fi
	[ -n "$ALWAYS_ON_TOP" ] && wish_exec "wm attributes .w -topmost $(tcl_str "$ALWAYS_ON_TOP")"
	[ -n "$MAXIMIZE" ] && wish_exec "wm attributes .w -fullscreen $MAXIMIZE"
	[ -n "$ALPHA" ] && wish_exec "wm attributes .w -alpha $(tcl_str "$ALPHA")"
	[ -n "$ICON" ] && wish_exec "image create photo imgobjicon -file $(tcl_str "${ICON}")" && wish_exec "wm iconphoto .w imgobjicon"
	[ -n "$RESIZABLE" ] && wish_exec "wm resizable .w $RESIZABLE $RESIZABLE"
	[ -n "$THEME" ] && wish_exec "ttk::style theme use $(tcl_str "$THEME")"
	[ -n "$ICONIFY" ] && wish_exec "wm iconify .w"
	[ -n "$HIDE" ] && wish_exec "wm withdraw .w"
	[ -n "$SHOW" ] && wish_exec "wm deiconify .w"
	[ -n "$CLOSE" ] && wish_exec "onexit"
	if [ -n "$HOTKEY" ]; then
		[ ! -v COMMAND ] && echo "hotkey command also needs the --command option." && die 23
		wish_exec "bind .w <$(tcl_esc "$HOTKEY")> \"onaction $(tcl_esc "$HOTKEY")\""
		write_command_file "$HOTKEY" "$COMMAND"
	fi
	if [ -n "$ON_CLOSE" ]; then
		[ ! -v COMMAND ] && echo "on-close command also needs the --command option." && die 23
		write_command_file "onclose" "$COMMAND"
	fi
	if [ -n "$ON_CLICK" ]; then
		[ ! -v COMMAND ] && echo "on-click command also needs the --command option." && die 26
		write_command_file "onclick" "$COMMAND"
	fi
	[ -v BACKGROUND ] && wish_exec ".w configure -background $(tcl_str "$BACKGROUND")" # todo -v? -n? inconsistent usage
	return 0
}
# custom user tk commands to be executed directly
handle_tk_commands() {
	[ -n "$VAR_NAME" ] && var=".w.$VAR_NAME" || var=
	wish_exec "$(tcl_esc "$var") ${TKCOMMAND}"
}

analyse_varname() {
	IS_NEW=0
	# (ignore ACTION for already-existing elements) -
	# always get type of given variable:
	wish_exec "
		set windowclass \"\"
		if {[winfo exists $WVAR_ESC]} {
			set windowclass [winfo class $WVAR_ESC]
		}"
	resp="$(wish_get "exec echo \$windowclass")"
	if [ -n "$resp" ] ; then
		TYPE="${resp,,}"
	else
		# var still unkwnown -> new element. use given ACTION
		IS_NEW=1
		if ([ -z "$X" ] && [ -z "$RELX" ]) || ([ -z "$Y" ] && [ -z "$RELY" ]) || [ -z "$WIDTH" ] || [ -z "$HEIGHT" ]; then
			echo "New element detected. x (-x or --relx) , y (-y or --rely), width (-w) and height (-h) options required."
			die 6
		fi
		[ -z "$ACTION" ] && echo "element '$VAR_NAME' unknown. If you wanted to add a new element, the syntax is 'tkbash <gui-id> <element> <variable> --options...'. For editing already existing elements, <element> can be omitted. <variable> can never be omitted." && die 15
		TYPE="${ACTION,,}"
	fi
	return 0
}

themed() {
	[ -v NOTHEME ] && echo $1 || echo "ttk::$1"
}

handle_element_commands() {
	case "$TYPE" in
		tbutton|button|ttk::button|submit)
			# set up element
			[ $IS_NEW = 1 ] && wish_exec "$(themed button) $WVAR_ESC -command \"onaction $WVAR_ESC\""
			# parse non-place options
			[ -v CONTENT ] && wish_exec "$WVAR_ESC configure -text $(tcl_str "${CONTENT}")"
			;;
		text|tk::text|input|edit|textfield|textarea)
			if [ $IS_NEW = 1 ]; then
				wish_exec "tk::text $WVAR_ESC -yscrollcommand \"${WVAR_ESC}_scroll set\""
				wish_exec "ttk::scrollbar ${WVAR_ESC}_scroll -command \"$WVAR_ESC yview\"" # placed seperately and dynamically below if desired by scrollbar option
			fi
			if [ "$SCROLLBAR" == 0 ]; then
				wish_exec "place forget ${WVAR_ESC}_scroll"
			elif [ "$SCROLLBAR" == 1 ] || [[ "$(wish_get "winfo ismapped ${WVAR_ESC}_scroll")" == 1 ]]; then
				# no scrollbar option, but scrollbar exists: this is a follow-up command for this text-element. in case it contains positional params, update scrollbar:  // todo check -n X || -n Y etc. ?
			 	local text_dimensions=($(wish_get "exec echo \"[winfo x $WVAR_ESC] [winfo y $WVAR_ESC] [winfo width $WVAR_ESC] [winfo height $WVAR_ESC]\""))
				[ -z "$X" ] && X=${text_dimensions[0]}; [ -z "$Y" ] && Y=${text_dimensions[1]}; [ -z "$WIDTH" ] && WIDTH=${text_dimensions[2]}; [ -z "$HEIGHT" ] && HEIGHT=${text_dimensions[3]}
				wish_exec "place ${WVAR_ESC}_scroll -x $((X+WIDTH)) -y $((Y)) -width 16 -height $((HEIGHT))"
			fi
			[ -v CONTENT ] && wish_exec "$WVAR_ESC delete 1.0 end" && wish_exec "$WVAR_ESC insert 1.0 $(tcl_str "$CONTENT")"
			[ "$IGNORE_RETURN" = 1 ] && wish_exec "bind $WVAR_ESC \"<Return>\" { break }"
			;;
		tlabel|timage|label|image|ttk::label|picture|img|bmp|bitmap|p)
			[ $IS_NEW = 1 ] && wish_exec "$(themed label) $WVAR_ESC -justify left -anchor nw"
			[ -v CONTENT ] && wish_exec "$WVAR_ESC configure -text $(tcl_str "${CONTENT}")"
			[ -v IMAGE ] && wish_exec "image create photo imgobj$WVAR_ESC -file $(tcl_str "${IMAGE}")" && wish_exec "$WVAR_ESC configure -image imgobj$WVAR_ESC"
			[ -n "$WIDTH" ] && wish_exec "$WVAR_ESC configure -wraplength $(tcl_str "$WIDTH")" # change width / add element: enable word wrap
			;;
		tcheckbutton|checkbutton|ttk::checkbutton|checkbox|check|tick|toggle)
			[ $IS_NEW = 1 ] && wish_exec "$(themed checkbutton) $WVAR_ESC -variable $(tcl_esc $VAR_NAME) -command \"onaction $WVAR_ESC\""
			[ -v CONTENT ] && wish_exec "$WVAR_ESC configure -text $(tcl_str "${CONTENT}")"
			[ -n "$SELECTED" ] && wish_exec "set $(tcl_esc $VAR_NAME) $SELECTED"
			;;
		tradiobutton|radiobutton|ttk::radiobutton|radio)
			if [ $IS_NEW = 1 ]; then
				[ -z "$GROUP" ] && echo "--group required" && die 19
				### determine value: (#radiogroupmembers)+1
				wish_exec "
					set matched_children \"\"
					foreach {child} [winfo children .w.] {
						if { [winfo class \"\$child\"] == \"TRadiobutton\" && [ \"\$child\" cget -variable] == $(tcl_esc "$GROUP") } {
							append matched_children \"\n\${child}\"
						}
					}"
				local groupmembers_amount=$(echo "$(wish_get "exec echo \"\$matched_children\"")" |egrep . |wc -l)
				#zero-indexed:
				local radionumber=$((groupmembers_amount)) # also considers empty response
				###
				wish_exec "$(themed radiobutton) $WVAR_ESC -variable $(tcl_esc "${GROUP}") -command \"onaction $WVAR_ESC\" -value ${radionumber}"
			 fi
			[ -v CONTENT ] && wish_exec "$WVAR_ESC configure -text $(tcl_str "${CONTENT}")"
			if [ "$SELECTED" == 1 ]; then
				local radionumber="$(wish_get "$WVAR_ESC cget -value")"
				wish_exec "set $(tcl_esc "$GROUP") $radionumber"
			fi
			;;
		tcombobox|combobox|ttk:combobox|select|dropdown|dropdownmenu)
			if [ $IS_NEW = 1 ]; then
				wish_exec "$(themed combobox) $WVAR_ESC -state readonly"
				wish_exec "bind $WVAR_ESC <<ComboboxSelected>> \"onaction $WVAR_ESC\""
			fi
			if [ -n "$CONTENT" ]; then
				IFS='|' && arr=($CONTENT) && unset IFS
				[[ "${#arr}" == 0 ]] && echo "invalid content specified. should have form \"option1|option2|option3...\"" && die 20
				local values=
				local selected_index=0
				for i in "${!arr[@]}"; do
					local val="${arr[$i]}"
					[ -z "$val" ] && selected_index=$((i-1)) || # empty val = two pipes in a row = use prev value as selected one.
						values="${values} $(tcl_str "$val")"
				done
				wish_exec "$WVAR_ESC configure -values [list $values]"
				wish_exec "$WVAR_ESC current $selected_index"
			fi
			;;
		*)
			echo "element >$TYPE< not supported." ; die 5
			;;
	esac
	### general options
	if [ -n "$DISABLED" ]; then
		[ "$DISABLED" = 0 ] && DISABLED=normal || DISABLED=disabled
		wish_exec "$WVAR_ESC configure -state ${DISABLED}"
	fi
	[ -v FOREGROUND ] && wish_exec "$WVAR_ESC configure -foreground $(tcl_str "$FOREGROUND")"
	[ -v BACKGROUND ] && wish_exec "$WVAR_ESC configure -background $(tcl_str "$BACKGROUND")"
	# create/override command file (label -c "..." would be possible, creates file but no action)
	[ -v COMMAND ] && write_command_file ".w.$VAR_NAME" "$COMMAND"
	# parse place options
	[ -n "$X" ] || [ -n "$Y" ] || [ -n "$RELX" ] || [ -n "$RELY" ] || [ -n "$WIDTH" ] || [ -n "$HEIGHT" ] &&
		wish_exec "place $WVAR_ESC ${X:+-x $((X))} ${RELX:+-relx $(tcl_str "$RELX")} ${Y:+-y $((Y))} ${RELY:+-relx $(tcl_str "$RELY")} ${WIDTH:+-width $((WIDTH))} ${HEIGHT:+-height $((HEIGHT))}" # todo X as x ?
	return 0
}

handle_get_commands() {
	case "$TYPE" in
		text)
			echo "$(wish_get "$WVAR_ESC get 1.0 end")"
			;;
		tcheckbutton)
			wish_exec "
				set check_value \"\"
				if {[info exists $(tcl_esc "$VAR_NAME")]} {
					set check_value \$$(tcl_esc "$VAR_NAME")
				}"
			echo "$(wish_get "exec echo \$check_value")"
			;;
		tradiobutton)
			local radio_var="$(wish_get "$WVAR_ESC cget -variable")"
			wish_exec "
				set radio_value \"\"
				if {[info exists $(tcl_esc "$radio_var")]} {
					set radio_value \$$(tcl_esc "$radio_var")
				}"
			echo "$(wish_get "exec echo \$radio_value")"
			;;
		tcombobox)
			echo "$(wish_get "$WVAR_ESC get")"
			;;
		*)
			echo "get-method for this element not supported :(" && exit 12
			;;
	esac
	return 0
}

if [ -v TKCOMMAND ]; then
	handle_tk_commands
elif [ "$ACTION" = "window" ]; then
	handle_window_commands
else
	analyse_varname

	if [ $GET_REQUEST = 0 ]; then
		# no get, but add/edit instead.
		handle_element_commands
	else
		# get variable value:
		handle_get_commands
	fi
fi

exit 0
